generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users
model User {
  id                    String   @id @default(uuid())
  walletAddress         String?  @unique @map("wallet_address")
  custodialWalletId     String?  @map("custodial_wallet_id")
  username              String   @unique
  displayName           String?  @map("display_name")
  avatarUrl             String?  @map("avatar_url")
  authProvider          String   @map("auth_provider")
  authProviderId        String   @map("auth_provider_id")
  isStreamer            Boolean  @default(false) @map("is_streamer")
  twitchId              String?  @map("twitch_id")
  twitchAccessToken     String?  @map("twitch_access_token")
  createdAt             DateTime @default(now()) @map("created_at")
  lastActiveAt          DateTime @default(now()) @map("last_active_at")

  // Stripe Connect fields
  stripeAccountId       String?  @map("stripe_account_id")
  stripeChargesEnabled  Boolean  @default(false) @map("stripe_charges_enabled")
  stripePayoutsEnabled  Boolean  @default(false) @map("stripe_payouts_enabled")

  // Relations
  episodes       Episode[]
  cards          Card[]
  withdrawals    Withdrawal[]
  templates      Template[]
  collaborations EpisodeCollaborator[]

  @@unique([authProvider, authProviderId])
  @@map("users")
}

// Episodes (Roots)
model Episode {
  id              String    @id @default(uuid())
  streamerId      String    @map("streamer_id")
  name            String
  artworkUrl      String?   @map("artwork_url")
  artworkHash     String?   @map("artwork_hash")
  cardPrice       Int       @default(0) @map("card_price")
  maxCards        Int?      @map("max_cards")
  gridSize        Int       @default(5) @map("grid_size")
  status          String    @default("draft")
  createdAt       DateTime  @default(now()) @map("created_at")
  launchedAt      DateTime? @map("launched_at")
  endedAt         DateTime? @map("ended_at")
  cardsMinted     Int       @default(0) @map("cards_minted")
  totalRevenue    Int       @default(0) @map("total_revenue")
  contractAddress String?   @map("contract_address")
  rootTokenId     String?   @map("root_token_id")
  shareCode       String    @unique @map("share_code")

  // Relations
  streamer            User                  @relation(fields: [streamerId], references: [id])
  eventDefinitions    EventDefinition[]
  cards               Card[]
  firedEvents         FiredEvent[]
  withdrawals         Withdrawal[]
  customWebhooks      CustomWebhook[]
  twitchSubscriptions TwitchSubscription[]
  chatKeywords        ChatKeyword[]
  collaborators       EpisodeCollaborator[]

  @@index([streamerId])
  @@index([status])
  @@index([shareCode])
  @@map("episodes")
}

// Event Definitions
model EventDefinition {
  id            String    @id @default(uuid())
  episodeId     String    @map("episode_id")
  name          String
  icon          String    @default("ðŸŽ¯")
  description   String?
  triggerType   String    @default("manual") @map("trigger_type")
  triggerConfig Json?     @map("trigger_config")
  firedAt       DateTime? @map("fired_at")
  firedCount    Int       @default(0) @map("fired_count")
  createdAt     DateTime  @default(now()) @map("created_at")
  sortOrder     Int       @default(0) @map("sort_order")

  // Relations
  episode      Episode       @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  firedEvents  FiredEvent[]
  chatKeywords ChatKeyword[]

  @@index([episodeId])
  @@map("event_definitions")
}

// Cards (Branches)
model Card {
  id            String    @id @default(uuid())
  episodeId     String    @map("episode_id")
  holderId      String    @map("holder_id")
  grid          Json
  status        String    @default("active")
  markedSquares Int       @default(0) @map("marked_squares")
  patterns      Json      @default("[]")
  mintedAt      DateTime  @default(now()) @map("minted_at")
  fruitedAt     DateTime? @map("fruited_at")
  paymentId     String?   @map("payment_id")
  pricePaid     Int       @default(0) @map("price_paid")
  branchTokenId String?   @map("branch_token_id")
  fruitTokenId  String?   @map("fruit_token_id")
  cardNumber    Int       @map("card_number")

  // Relations
  episode Episode @relation(fields: [episodeId], references: [id])
  holder  User    @relation(fields: [holderId], references: [id])

  @@unique([episodeId, holderId])
  @@index([episodeId])
  @@index([holderId])
  @@index([status])
  @@map("cards")
}

// Fired Events Log
model FiredEvent {
  id                String   @id @default(uuid())
  episodeId         String   @map("episode_id")
  eventDefinitionId String   @map("event_definition_id")
  firedAt           DateTime @default(now()) @map("fired_at")
  firedBy           String   @map("fired_by")
  cardsAffected     Int      @default(0) @map("cards_affected")
  triggerData       Json?    @map("trigger_data")

  // Relations
  episode         Episode         @relation(fields: [episodeId], references: [id])
  eventDefinition EventDefinition @relation(fields: [eventDefinitionId], references: [id])

  @@index([episodeId])
  @@index([firedAt])
  @@map("fired_events")
}

// Refresh Tokens
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

// Withdrawals
model Withdrawal {
  id               String    @id @default(uuid())
  streamerId       String    @map("streamer_id")
  episodeId        String    @map("episode_id")
  amount           Int                              // Amount in cents
  platformFee      Int       @map("platform_fee")   // Fee taken by platform
  netAmount        Int       @map("net_amount")     // Amount to streamer
  status           String    @default("pending")    // pending, processing, completed, failed
  stripeTransferId String?   @map("stripe_transfer_id")
  createdAt        DateTime  @default(now()) @map("created_at")
  completedAt      DateTime? @map("completed_at")
  failedReason     String?   @map("failed_reason")

  // Relations
  streamer User    @relation(fields: [streamerId], references: [id])
  episode  Episode @relation(fields: [episodeId], references: [id])

  @@index([streamerId])
  @@index([episodeId])
  @@index([status])
  @@map("withdrawals")
}

// Pending Payments (for tracking mint requests before payment completes)
model PendingPayment {
  id              String   @id @default(uuid())
  episodeId       String   @map("episode_id")
  userId          String   @map("user_id")
  paymentIntentId String   @unique @map("payment_intent_id")
  amount          Int
  status          String   @default("pending") // pending, completed, expired, failed
  createdAt       DateTime @default(now()) @map("created_at")
  expiresAt       DateTime @map("expires_at")

  @@index([episodeId])
  @@index([userId])
  @@index([paymentIntentId])
  @@map("pending_payments")
}

// Custom Webhooks for external integrations
model CustomWebhook {
  id         String    @id @default(uuid())
  episodeId  String    @map("episode_id")
  name       String
  secret     String // HMAC secret for verification
  isActive   Boolean   @default(true) @map("is_active")
  createdAt  DateTime  @default(now()) @map("created_at")
  lastUsedAt DateTime? @map("last_used_at")
  usageCount Int       @default(0) @map("usage_count")

  // Relations
  episode Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@index([episodeId])
  @@index([secret])
  @@map("custom_webhooks")
}

// Twitch EventSub Subscriptions
model TwitchSubscription {
  id             String   @id @default(uuid())
  episodeId      String   @map("episode_id")
  subscriptionId String   @unique @map("subscription_id") // Twitch subscription ID
  type           String // e.g., "channel.follow", "channel.cheer"
  status         String   @default("pending") // pending, enabled, revoked
  secret         String   // Webhook verification secret (persisted in DB for server restarts)
  createdAt      DateTime @default(now()) @map("created_at")

  // Relations
  episode Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@index([episodeId])
  @@index([subscriptionId])
  @@map("twitch_subscriptions")
}

// Chat Keywords for automated event triggering
model ChatKeyword {
  id              String    @id @default(uuid())
  episodeId       String    @map("episode_id")
  eventId         String    @map("event_id") // EventDefinition to trigger
  keyword         String // Keyword or phrase to detect
  matchType       String    @default("contains") // exact, contains, startswith, regex
  caseSensitive   Boolean   @default(false) @map("case_sensitive")
  cooldownSeconds Int       @default(0) @map("cooldown_seconds") // Min seconds between triggers
  lastTriggeredAt DateTime? @map("last_triggered_at")
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  episode         Episode         @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  eventDefinition EventDefinition @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([episodeId])
  @@index([keyword])
  @@map("chat_keywords")
}

// Bingo Templates (reusable event presets)
model Template {
  id          String   @id @default(uuid())
  creatorId   String   @map("creator_id")
  name        String
  description String?
  category    String   @default("general") // gaming, irl, music, etc.
  events      Json // Array of event definitions
  gridSize    Int      @default(5) @map("grid_size")
  isPublic    Boolean  @default(false) @map("is_public")
  usageCount  Int      @default(0) @map("usage_count")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  creator User @relation(fields: [creatorId], references: [id])

  @@index([creatorId])
  @@index([category])
  @@index([isPublic])
  @@map("templates")
}

// Episode Collaborators (multi-streamer support)
model EpisodeCollaborator {
  id           String   @id @default(uuid())
  episodeId    String   @map("episode_id")
  userId       String   @map("user_id")
  role         String   @default("co-host") // co-host, moderator
  permissions  Json     @default("[]") // Array of permission strings: fire_events, view_stats, manage_events
  invitedAt    DateTime @default(now()) @map("invited_at")
  acceptedAt   DateTime? @map("accepted_at")
  status       String   @default("pending") // pending, accepted, declined, removed
  revenueShare Int      @default(0) @map("revenue_share") // Percentage (0-100) of revenue to share

  // Relations
  episode Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id])

  @@unique([episodeId, userId])
  @@index([episodeId])
  @@index([userId])
  @@index([status])
  @@map("episode_collaborators")
}
